Detailed description of the implementation:
In this program, we implement a 32-bit ALU. Its operations include AND, OR, addition, subtraction, NOR, NAND and SLT (set less than). 
First, we have to write a 1-bit ALU, which is name as ¡°alu_top¡±. In ¡°alu_top¡±, we do five functions, which is ¡°mux_2¡±, ¡°and¡±, ¡°or¡±, ¡°add¡± and ¡°mux¡±. In ¡°mux_2¡±, we determine the answer whether need to do invert or not. If the first bit of ALU_control input is 1, we do invert. The ¡°and¡± and ¡°or¡± operation, we just simply use the and and or operation which is already stored in the system. In the ¡°add¡± function, we add a and b together and store the answer and the carry. The carry will added to the next 1-bit ALU and if there is overflow ,will be save to ¡°overflow¡±. In the ¡°mux¡± function, we choose the result according to the inputted operation and output it. 
After completed the ¡°alu_top¡±, we started to complete the 32_bit alu. In the 32-bit ALU, is rst_n is equal to 1, we started to load the input which Detailed description of the implementation:
In this program, we implement a 32-bit ALU. Its operations include AND, OR, addition, subtraction, NOR, NAND and SLT (set less than). 
First, we have to write a 1-bit ALU, which is name as ¡°alu_top¡±. In ¡°alu_top¡±, we do five functions, which is ¡°mux_2¡±, ¡°and¡±, ¡°or¡±, ¡°add¡± and ¡°mux¡±. In ¡°mux_2¡±, we determine the answer whether need to do invert or not. If the first bit of ALU_control input is 1, we do invert. The ¡°and¡± and ¡°or¡± operation, we just simply use the and and or operation which is already stored in the system. In the ¡°add¡± function, we add a and b together and store the answer and the carry. The carry will added to the next 1-bit ALU and if there is overflow ,will be save to ¡°overflow¡±. In the ¡°mux¡± function, we choose the result according to the inputted operation and output it. 
After completed the ¡°alu_top¡±, we started to complete the 32_bit alu. In the 32-bit ALU, is rst_n is equal to 1, we started to load the input which 